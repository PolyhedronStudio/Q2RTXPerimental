/********************************************************************
*
*	Copyright (C) 1997-2001 Id Software, Inc.
*	Copyright (C) 2003-2008 Andrey Nazarov
*	Copyright (C) 2019, NVIDIA CORPORATION. All rights reserved.
*
*	This program is free software; you can redistribute it and/or
*	modify it under the terms of the GNU General Public License as
*	published by the Free Software Foundation; either version 2 of the
*	License, or (at your option) any later version.
*
********************************************************************/

/********************************************************************
*
*	Module Name: Image Loading and Management System
*
*	This module provides comprehensive image loading, processing, and
*	management functionality for the Quake II RTX Perimental renderer.
*	It handles multiple image formats (PCX, WAL, TGA, PNG, JPG), texture
*	caching, mipmap generation, palette conversion, and screenshot capture.
*
*	Key Features:
*	- Multi-format image loading with automatic format detection
*	- Texture override system for HD asset replacement
*	- Hash-based image caching and lookup
*	- 8-bit paletted to 32-bit RGBA conversion
*	- Mipmap generation and resampling
*	- Screenshot capture (TGA, PNG, JPG, HDR formats)
*	- Floodfill anti-aliasing for transparent textures
*	- Asynchronous screenshot writing
*
********************************************************************/

#include "shared/shared.h"
#include "common/async.h"
#include "common/common.h"
#include "common/cvar.h"
#include "common/files.h"
#include "../client/cl_client.h"
#include "refresh/images.h"
#include "system/system.h"
#include "format/pcx.h"
#include "format/wal.h"
#include "stb_image.h"
#include "stb_image_write.h"

#include <assert.h>

#define R_COLORMAP_PCX    "pics/colormap.pcx"

#define IMG_LOAD(x) \
    static int IMG_Load##x(byte *rawdata, size_t rawlen, \
        image_t *image, byte **pic)

/**
*	@brief	STB image write callback - writes data to screenshot file.
*	@param	context	Screenshot context containing file pointer.
*	@param	data	Image data to write.
*	@param	size	Number of bytes to write.
**/
void stbi_write(void *context, void *data, int size)
{
	fwrite(data, size, 1, ((screenshot_t *) context)->fp);
}

extern cvar_t* vid_rtx;
extern cvar_t* gl_use_hd_assets;


/**
*
*
*
*	Image Flood Filling:
*
*
*
**/

typedef struct {
    short       x, y;
} floodfill_t;

// must be a power of 2
#define FLOODFILL_FIFO_SIZE 0x1000
#define FLOODFILL_FIFO_MASK (FLOODFILL_FIFO_SIZE - 1)

// Helper macro to process a single pixel in flood fill algorithm
#define FLOODFILL_STEP(off, dx, dy) \
    do { \
        if (pos[off] == fillcolor) { \
            pos[off] = 255; \
            fifo[inpt].x = x + (dx); \
            fifo[inpt].y = y + (dy); \
            inpt = (inpt + 1) & FLOODFILL_FIFO_MASK; \
        } else if (pos[off] != 255) { \
            fdc = pos[off]; \
        } \
    } while(0)

/**
*	@brief	Fill background pixels of an 8-bit indexed image to prevent mipmap haloing.
*	@param	skin		8-bit indexed pixel data to process.
*	@param	skinwidth	Image width in pixels.
*	@param	skinheight	Image height in pixels.
*
*	This flood-fill algorithm replaces transparent (index 255) background pixels
*	with nearby solid colors. This prevents "haloing" artifacts when mipmaps are
*	generated by ensuring transparent edges blend with appropriate colors rather
*	than black or uninitialized data.
*
*	The algorithm uses a FIFO queue to spread from the edges inward, replacing
*	transparent pixels with colors from adjacent solid pixels.
*
*	@note	Uses index 255 as the transparent marker color.
**/
static q_noinline void IMG_FloodFill(byte *skin, int skinwidth, int skinheight)
{
    byte                fillcolor = *skin; // assume this is the pixel to fill
    floodfill_t         fifo[FLOODFILL_FIFO_SIZE];
    int                 inpt = 0, outpt = 0;
    int                 filledcolor = 0; // FIXME: fixed black

    // can't fill to filled color or to transparent color (used as visited marker)
    if (fillcolor == filledcolor || fillcolor == 255) {
        return;
    }

    // Start flood fill from origin
    fifo[inpt].x = 0, fifo[inpt].y = 0;
    inpt = (inpt + 1) & FLOODFILL_FIFO_MASK;

    // Process queue until empty
    while (outpt != inpt) {
        int         x = fifo[outpt].x, y = fifo[outpt].y;
        int         fdc = filledcolor;
        byte        *pos = &skin[x + skinwidth * y];

        outpt = (outpt + 1) & FLOODFILL_FIFO_MASK;

        // Check and queue adjacent pixels (4-way connectivity)
        if (x > 0) FLOODFILL_STEP(-1, -1, 0);
        if (x < skinwidth - 1) FLOODFILL_STEP(1, 1, 0);
        if (y > 0) FLOODFILL_STEP(-skinwidth, 0, -1);
        if (y < skinheight - 1) FLOODFILL_STEP(skinwidth, 0, 1);

        // Replace current pixel with filled color
        skin[x + skinwidth * y] = fdc;
    }
}


/**
*
*
*
*	PCX Image Loading:
*
*
*
**/

/**
*	@brief	Decode a PCX format image file into raw pixel and palette data.
*	@param	rawdata	PCX file data buffer.
*	@param	rawlen	Length of PCX data in bytes.
*	@param	pixels	Output buffer for decoded pixel data (can be NULL).
*	@param	palette	Output buffer for 256-color palette (can be NULL).
*	@param	width	Output parameter for image width.
*	@param	height	Output parameter for image height.
*	@return	Q_ERR_SUCCESS on success, error code on failure.
*
*	PCX Format Layout:
*	- Header (128 bytes): dimension, encoding info
*	- RLE-compressed pixel data
*	- 768-byte RGB palette at end of file
*
*	The function validates header fields, performs RLE decompression,
*	and extracts the palette from the last 768 bytes of the file.
*
*	@note	Only supports 8-bit, single plane, RLE-encoded PCX files.
**/
static int IMG_DecodePCX(byte *rawdata, size_t rawlen, byte *pixels,
                         byte *palette, int *width, int *height)
{
    byte    *raw, *end;
    dpcx_t  *pcx;
    int     x, y, w, h, scan;
    int     dataByte, runLength;

    //
    // parse the PCX file
    //
    if (rawlen < sizeof(dpcx_t)) {
        return Q_ERR_FILE_TOO_SMALL;
    }

    pcx = (dpcx_t *)rawdata;

    if (pcx->manufacturer != 10 || pcx->version != 5) {
        return Q_ERR_UNKNOWN_FORMAT;
    }

    if (pcx->encoding != 1 || pcx->bits_per_pixel != 8) {
        Com_SetLastError("invalid encoding or bits per pixel");
        return Q_ERR_INVALID_FORMAT;
    }

    w = (LittleShort(pcx->xmax) - LittleShort(pcx->xmin)) + 1;
    h = (LittleShort(pcx->ymax) - LittleShort(pcx->ymin)) + 1;
    if (w < 1 || h < 1 || w > 640 || h > 480) {
        Com_SetLastError("invalid image dimensions");
        return Q_ERR_INVALID_FORMAT;
    }

    if (pcx->color_planes != 1) {
        Com_SetLastError("invalid number of color planes");
        return Q_ERR_INVALID_FORMAT;
    }

    scan = LittleShort(pcx->bytes_per_line);
    if (scan < w) {
        Com_SetLastError("invalid number of bytes per line");
        return Q_ERR_INVALID_FORMAT;
    }

    //
    // get palette
    //
    if (palette) {
        if (rawlen < 768) {
            return Q_ERR_FILE_TOO_SMALL;
        }
        memcpy(palette, (byte *)pcx + rawlen - 768, 768);
    }

    //
    // get pixels
    //
    if (pixels) {
        raw = pcx->data;
        end = (byte *)pcx + rawlen;
        for (y = 0; y < h; y++, pixels += w) {
            for (x = 0; x < scan;) {
                if (raw >= end)
                    return Q_ERR_BAD_RLE_PACKET;
                dataByte = *raw++;

                if ((dataByte & 0xC0) == 0xC0) {
                    runLength = dataByte & 0x3F;
                    if (x + runLength > scan)
                        return Q_ERR_BAD_RLE_PACKET;
                    if (raw >= end)
                        return Q_ERR_BAD_RLE_PACKET;
                    dataByte = *raw++;
                } else {
                    runLength = 1;
                }

                while (runLength--) {
                    if (x < w)
                        pixels[x] = dataByte;
                    x++;
                }
            }
        }
    }

    if (width)
        *width = w;
    if (height)
        *height = h;

    return Q_ERR_SUCCESS;
}

/**
*	@brief	Convert 8-bit paletted image data to 32-bit RGBA format with alpha fringe prevention.
*	@param	out		Destination buffer for 32-bit RGBA pixel data.
*	@param	in		Source buffer containing 8-bit indexed pixel data.
*	@param	width	Image width in pixels.
*	@param	height	Image height in pixels.
*	@return	Flags indicating image properties (IF_PALETTED | IF_TRANSPARENT or IF_PALETTED | IF_OPAQUE).
*
*	Performs conversion from 8-bit indexed color to 32-bit RGBA using the d_8to24table palette.
*	For transparent pixels (index 255), the function searches adjacent pixels (8-way connectivity)
*	to find a suitable RGB value, preventing dark "fringes" or halos around transparent edges
*	when mipmaps are generated or the texture is filtered.
*
*	@note	Index 255 is treated as the transparent color marker.
*	@note	Transparent pixels get alpha=0, opaque pixels get alpha=255.
**/
static int IMG_Unpack8(uint32_t *out, const uint8_t *in, int width, int height)
{
    int         x, y, p;
    bool        has_alpha = false;

    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            p = *in;
            if (p == 255) {
                has_alpha = true;
                // Transparent pixel - search 8 adjacent neighbors for a solid color
                // to prevent dark/black fringes when texture filtering or mipmapping occurs
                if (y > 0 && *(in - width) != 255)
                    p = *(in - width);
                else if (y < height - 1 && *(in + width) != 255)
                    p = *(in + width);
                else if (x > 0 && *(in - 1) != 255)
                    p = *(in - 1);
                else if (x < width - 1 && *(in + 1) != 255)
                    p = *(in + 1);
                else if (y > 0 && x > 0 && *(in - width - 1) != 255)
                    p = *(in - width - 1);
                else if (y > 0 && x < width - 1 && *(in - width + 1) != 255)
                    p = *(in - width + 1);
                else if (y < height - 1 && x > 0 && *(in + width - 1) != 255)
                    p = *(in + width - 1);
                else if (y < height - 1 && x < width - 1 && *(in + width + 1) != 255)
                    p = *(in + width + 1);
                else
                    p = 0;
                // Copy RGB components only, leave alpha at 0 for transparency
                *out = d_8to24table[p] & U32_RGB;
            } else {
                *out = d_8to24table[p];
            }
            in++;
            out++;
        }
    }

    if (has_alpha)
        return IF_PALETTED | IF_TRANSPARENT;

    return IF_PALETTED | IF_OPAQUE;
}

/**
*	@brief	Load a PCX format image file.
*	@param	rawdata	PCX file data buffer.
*	@param	rawlen	Length of PCX data in bytes.
*	@param	image	Image structure to populate with dimensions and flags.
*	@param	pic		Output parameter for allocated pixel data (32-bit RGBA).
*	@return	Q_ERR_SUCCESS on success, error code on failure.
*
*	Loads PCX images with dimensions up to 640x480. Decodes RLE-compressed data,
*	applies flood-fill anti-aliasing for skin textures, and converts 8-bit indexed
*	color to 32-bit RGBA format.
*
*	@note	Uses a static 640x480 buffer for intermediate 8-bit data.
*	@note	Skin images receive flood-fill processing to prevent mipmap artifacts.
**/
IMG_LOAD(PCX)
{
    byte        buffer[640 * 480];
    int         w, h;
    int         ret;

    ret = IMG_DecodePCX(rawdata, rawlen, buffer, NULL, &w, &h);
    if (ret < 0)
        return ret;

    // Apply flood-fill for skin textures to prevent edge artifacts
    if (image->type == IT_SKIN)
        IMG_FloodFill(buffer, w, h);

    *pic = IMG_AllocPixels(w * h * 4);

    image->upload_width = image->width = w;
    image->upload_height = image->height = h;
    image->flags |= IMG_Unpack8((uint32_t *)*pic, buffer, w, h);

    return Q_ERR_SUCCESS;
}


/**
*
*
*
*	WAL Image Loading:
*
*
*
**/

/**
*	@brief	Load a WAL format texture file (Quake 2 wall texture format).
*	@param	rawdata	WAL file data buffer.
*	@param	rawlen	Length of WAL data in bytes.
*	@param	image	Image structure to populate with dimensions and flags.
*	@param	pic		Output parameter for allocated pixel data (32-bit RGBA).
*	@return	Q_ERR_SUCCESS on success, error code on failure.
*
*	WAL is the native Quake 2 wall texture format, storing 8-bit indexed mipmap
*	levels. This loader extracts the base mip level (offsets[0]) and converts
*	it to 32-bit RGBA format.
*
*	@note	Supports textures up to MAX_TEXTURE_SIZE in either dimension.
*	@note	Only loads the highest resolution mip level; mipmaps regenerated if needed.
**/
IMG_LOAD(WAL)
{
    miptex_t    *mt;
    unsigned    w, h, offset, size, endpos;

    if (rawlen < sizeof(miptex_t)) {
        return Q_ERR_FILE_TOO_SMALL;
    }

    mt = (miptex_t *)rawdata;

    w = LittleLong(mt->width);
    h = LittleLong(mt->height);
    if (w < 1 || h < 1 || w > MAX_TEXTURE_SIZE || h > MAX_TEXTURE_SIZE) {
        Com_SetLastError("invalid image dimensions");
        return Q_ERR_INVALID_FORMAT;
    }

    size = w * h;

    offset = LittleLong(mt->offsets[0]);
    endpos = offset + size;
    if (endpos < offset || endpos > rawlen) {
        return Q_ERR_BAD_EXTENT;
    }

    *pic = IMG_AllocPixels(size * 4);

    image->upload_width = image->width = w;
    image->upload_height = image->height = h;
    image->flags |= IMG_Unpack8((uint32_t *)*pic, (uint8_t *)mt + offset, w, h);

    return Q_ERR_SUCCESS;
}

/**
*
*
*
*	STB Image Loading (TGA, PNG, JPG):
*
*
*
**/

/**
*	@brief	Check if extended pixel formats (16-bit, HDR) are supported by the renderer.
*	@return	True if VKPT renderer is active, false otherwise.
*
*	Extended formats like 16-bit grayscale are only supported in the VKPT path tracer.
**/
static bool supports_extended_pixel_format(void)
{
	return cls.ref_type == REF_TYPE_VKPT;
}

/**
*	@brief	Load an image using the STB image library (TGA, PNG, JPG formats).
*	@param	rawdata	Image file data buffer.
*	@param	rawlen	Length of image data in bytes.
*	@param	image	Image structure to populate with dimensions and format info.
*	@param	pic		Output parameter for allocated pixel data.
*	@return	Q_ERR_SUCCESS on success, Q_ERR_LIBRARY_ERROR on failure.
*
*	Loads modern image formats using stb_image. Automatically detects format and
*	bit depth. For VKPT renderer, supports special case of 16-bit grayscale images
*	(PF_R16_UNORM), otherwise loads as standard 8-bit RGBA (PF_R8G8B8A8_UNORM).
*
*	@note	3-channel images are flagged as opaque (IF_OPAQUE).
*	@note	Grayscale 16-bit support requires VKPT renderer.
**/
IMG_LOAD(STB)
{
	int w, h, channels;
	byte* data = NULL;
	// Check for extended format support (16-bit grayscale)
	if(supports_extended_pixel_format())
	{
		int img_comp;
		stbi_info_from_memory(rawdata, rawlen, NULL, NULL, &img_comp);
		bool img_is_16 = stbi_is_16_bit_from_memory(rawdata, rawlen);

		if(img_comp == 1 && img_is_16)
		{
			// Load as 16-bit single-channel grayscale for heightmaps/displacement
			data = (byte*)stbi_load_16_from_memory(rawdata, rawlen, &w, &h, &channels, 1);
			image->pixel_format = PF_R16_UNORM;
		}
		// else: fall through to standard 8-bit RGBA path
	}
	if(!data)
	{
		// Standard path: load as 8-bit RGBA
		data = stbi_load_from_memory(rawdata, rawlen, &w, &h, &channels, 4);
		image->pixel_format = PF_R8G8B8A8_UNORM;
	}

	if (!data)
	{
		Com_SetLastError(stbi_failure_reason());
		return Q_ERR_LIBRARY_ERROR;
	}

	*pic = data;

	image->upload_width = image->width = w;
	image->upload_height = image->height = h;

	if (channels == 3)
		image->flags |= IF_OPAQUE;

    return Q_ERR_SUCCESS;
}


/**
*
*
*
*	Screenshot Capture:
*
*
*
**/

/**
*	@brief	Save a screenshot in TGA format.
*	@param	s	Screenshot structure containing pixel data and file handle.
*	@return	Q_ERR_SUCCESS on success, Q_ERR_LIBRARY_ERROR on failure.
*
*	Writes 24-bit uncompressed TGA format. Image is flipped vertically during write
*	to match standard TGA orientation.
**/
static int IMG_SaveTGA(screenshot_t *restrict s)
{
	stbi_flip_vertically_on_write(1);
	int ret = stbi_write_tga_to_func(stbi_write, s, s->width, s->height, 3, s->pixels);

	if (ret) 
		return Q_ERR_SUCCESS;

	Com_SetLastError(stbi_failure_reason());
	return Q_ERR_LIBRARY_ERROR;
}

/**
*	@brief	Save a screenshot in JPEG format.
*	@param	s	Screenshot structure containing pixel data, file handle, and quality parameter.
*	@return	Q_ERR_SUCCESS on success, Q_ERR_LIBRARY_ERROR on failure.
*
*	Writes JPEG format with quality level specified in s->param (1-100, where 100 is best).
*	Provides good compression for photographic content but loses quality.
*
*	@note	Quality parameter comes from r_screenshot_quality cvar or command line argument.
**/
static int IMG_SaveJPG(screenshot_t *restrict s)
{
	stbi_flip_vertically_on_write(1);
	int ret = stbi_write_jpg_to_func(stbi_write, s, s->width, s->height, 3, s->pixels, s->param);

	if (ret)
		return Q_ERR_SUCCESS;

	Com_SetLastError(stbi_failure_reason());
	return Q_ERR_LIBRARY_ERROR;
}


/**
*	@brief	Save a screenshot in PNG format.
*	@param	s	Screenshot structure containing pixel data, file handle, and compression parameter.
*	@return	Q_ERR_SUCCESS on success, Q_ERR_LIBRARY_ERROR on failure.
*
*	Writes lossless PNG format with compression level in s->param (0-9, where 9 is maximum).
*	Best for UI screenshots or when lossless quality is required.
*
*	@note	Compression parameter comes from r_screenshot_compression cvar.
**/
static int IMG_SavePNG(screenshot_t *restrict s)
{
	stbi_flip_vertically_on_write(1);
	int ret = stbi_write_png_to_func(stbi_write, s, s->width, s->height, 3, s->pixels, s->rowbytes);

	if (ret)
		return Q_ERR_SUCCESS;

	Com_SetLastError(stbi_failure_reason());
	return Q_ERR_LIBRARY_ERROR;
}

/**
*	@brief	Save a screenshot in HDR (Radiance RGBE) format.
*	@param	s	Screenshot structure containing floating-point HDR pixel data and file handle.
*	@return	Q_ERR_SUCCESS on success, Q_ERR_LIBRARY_ERROR on failure.
*
*	Writes Radiance HDR format with floating-point RGB values. Only available when
*	rendering in HDR mode. Captures full dynamic range for post-processing.
*
*	@note	s->pixels must point to float* data, not byte* data.
*	@note	Only supported in HDR rendering mode (VKPT with HDR enabled).
**/
static int IMG_SaveHDR(screenshot_t *restrict s)
{
	stbi_flip_vertically_on_write(1);
	// NOTE: The 'pixels' pointer is byte*, but HDR writing requires float* data!
	int ret = stbi_write_hdr_to_func(stbi_write, s, s->width, s->height, 3, (float*)s->pixels);

	if (ret)
		return Q_ERR_SUCCESS;

	Com_SetLastError(stbi_failure_reason());
	return Q_ERR_LIBRARY_ERROR;
}

// Console variables for screenshot configuration
static cvar_t *r_screenshot_format;
static cvar_t *r_screenshot_quality;
static cvar_t *r_screenshot_async;
static cvar_t* r_screenshot_compression;
static cvar_t* r_screenshot_message;
static cvar_t *r_screenshot_template;

/**
*	@brief	Find position of trailing character sequence in template string.
*	@param	s	Template string to search.
*	@param	ch	Character to find trailing sequence of.
*	@return	Starting position of trailing character sequence.
*
*	Helper for parsing screenshot template strings. Finds where the trailing 'X'
*	characters start in templates like "quakeXXX".
**/
static int suffix_pos(const char *s, int ch)
{
    int pos = strlen(s);
    while (pos > 0 && s[pos - 1] == ch)
        pos--;
    return pos;
}

/**
*	@brief	Parse screenshot filename template from cvar.
*	@param	var		Template cvar (e.g., "gl_screenshot_template").
*	@param	buffer	Output buffer for parsed template basename.
*	@param	size	Size of output buffer.
*	@return	Number of digits for auto-numbering (3-9).
*
*	Parses templates like "quakeXXX" where X's indicate digit width for auto-numbering.
*	Falls back to "quake" (3 digits) if template is invalid.
**/
static int parse_template(cvar_t *var, char *buffer, size_t size)
{
    if (FS_NormalizePathBuffer(buffer, var->string, size) < size) {
        FS_CleanupPath(buffer);
        int start = suffix_pos(buffer, 'X');
        int width = strlen(buffer) - start;
        buffer[start] = 0;
        if (width >= 3 && width <= 9)
            return width;
    }

    Com_WPrintf("Bad value '%s' for '%s'. Falling back to '%s'.\n",
                var->string, var->name, var->default_string);
    Cvar_Reset(var);
    Q_strlcpy(buffer, "quake", size);
    return 3;
}

/**
*	@brief	Create a screenshot file with unique or specified name.
*	@param	buffer	Output buffer for full screenshot file path.
*	@param	size	Size of output buffer.
*	@param	f		Output parameter for opened file handle.
*	@param	name	Optional user-specified name (NULL for auto-generated).
*	@param	ext		File extension including dot (e.g., ".png").
*	@return	0 on success, error code on failure.
*
*	If name is provided, creates screenshot with that exact name (may overwrite).
*	Otherwise, auto-generates numbered filename using template, finding first
*	unused slot from 000 to 999 (or higher based on template width).
*
*	@note	Creates screenshots/ directory if needed.
**/
static int create_screenshot(char *buffer, size_t size, FILE **f,
                             const char *name, const char *ext)
{
    char temp[MAX_OSPATH];
    int i, ret, width, count;

    if (name && *name) {
        // save to user supplied name
        if (FS_NormalizePathBuffer(temp, name, sizeof(temp)) >= sizeof(temp)) {
            return Q_ERR(ENAMETOOLONG);
        }
        FS_CleanupPath(temp);
        if (Q_snprintf(buffer, size, "%s/screenshots/%s%s", fs_gamedir, temp, ext) >= size) {
            return Q_ERR(ENAMETOOLONG);
        }
        if ((ret = FS_CreatePath(buffer)) < 0) {
            return ret;
        }
        if (!(*f = fopen(buffer, "wb"))) {
            return Q_ERRNO;
        }
        return 0;
    }

    width = parse_template(r_screenshot_template, temp, sizeof(temp));

    // create the directory
    if (Q_snprintf(buffer, size, "%s/screenshots/%s", fs_gamedir, temp) >= size) {
        return Q_ERR(ENAMETOOLONG);
    }
    if ((ret = FS_CreatePath(buffer)) < 0) {
        return ret;
    }

    count = 1;
    for (i = 0; i < width; i++)
        count *= 10;

    // Find first available numbered filename
    for (i = 0; i < count; i++) {
        if (Q_snprintf(buffer, size, "%s/screenshots/%s%0*d%s", fs_gamedir, temp, width, i, ext) >= size) {
            return Q_ERR(ENAMETOOLONG);
        }
        if ((*f = Q_fopen(buffer, "wxb"))) {
            return 0;
        }
        ret = Q_ERRNO;
        if (ret != Q_ERR(EEXIST)) {
            return ret;
        }
    }
    
    return Q_ERR_OUT_OF_SLOTS;
}

/**
*	@brief	Check if renderer is in HDR mode.
*	@return	True if HDR rendering is active, false otherwise.
**/
static bool is_render_hdr(void)
{
    return R_IsHDR && R_IsHDR();
}

/**
*	@brief	Async worker callback for encoding and writing screenshot data.
*	@param	arg	Screenshot context (screenshot_t*).
*
*	Runs on worker thread when async screenshots are enabled. Performs the actual
*	image encoding and file write operations off the main thread.
**/
static void screenshot_work_cb(void *arg)
{
    screenshot_t *s = arg;
    s->status = s->save_cb(s);
}

/**
*	@brief	Completion callback for screenshot operations (async or sync).
*	@param	arg	Screenshot context (screenshot_t*).
*
*	Closes file handle, frees memory, and reports status to console. For async
*	operations, also frees the screenshot context itself.
**/
static void screenshot_done_cb(void *arg)
{
    screenshot_t *s = arg;

    if (fclose(s->fp) && !s->status)
        s->status = Q_ERRNO;
    Z_Free(s->pixels);

    if (s->status < 0) {
        const char *msg;

        if (s->status == Q_ERR_LIBRARY_ERROR && !s->async)
            msg = Com_GetLastError();
        else
            msg = Q_ErrorString(s->status);

        Com_EPrintf("Couldn't write %s: %s\n", s->filename, msg);
        remove(s->filename);
    } else if (r_screenshot_message->integer) {
        Com_Printf("Wrote %s\n", s->filename);
    }

    if (s->async) {
        Z_Free(s->filename);
        Z_Free(s);
    }
}

/**
*	@brief	Capture and save a screenshot in LDR (8-bit) format.
*	@param	name	Optional user-specified filename (NULL for auto-generated).
*	@param	ext		File extension including dot (e.g., ".png", ".jpg", ".tga").
*	@param	save_cb	Encoder callback function (IMG_SavePNG, IMG_SaveJPG, or IMG_SaveTGA).
*	@param	async	If true, encode/write on worker thread; if false, do on main thread.
*	@param	param	Format-specific parameter (JPEG quality or PNG compression level).
*
*	Reads pixels from framebuffer and processes screenshot. In async mode, queues
*	encoding work to avoid main thread stalls. Warns if attempted in HDR mode.
**/
static void make_screenshot(const char *name, const char *ext,
                            save_cb_t save_cb, bool async, int param)
{
    char        buffer[MAX_OSPATH];
    FILE        *fp;
    int         ret;

    if(is_render_hdr()) {
        Com_WPrintf("Screenshot format not supported in HDR mode\n");
        return;
    }
    ret = create_screenshot(buffer, sizeof(buffer), &fp, name, ext);
    if (ret < 0) {
        Com_EPrintf("Couldn't create screenshot: %s\n", Q_ErrorString(ret));
        return;
    }

    screenshot_t s = {
        .save_cb = save_cb,
        .fp = fp,
        .filename = async ? Z_CopyString(buffer) : buffer,
        .status = -1,
        .param = param,
        .async = async,
    };

    IMG_ReadPixels(&s);

    // Process screenshot synchronously or queue for async processing
    if (async) {
        asyncwork_t work = {
            .work_cb = screenshot_work_cb,
            .done_cb = screenshot_done_cb,
            .cb_arg = Z_CopyStruct(&s),
        };
        Com_QueueAsyncWork(&work);
    } else {
        screenshot_work_cb(&s);
        screenshot_done_cb(&s);
    }
}

/**
*	@brief	Capture and save a screenshot in HDR (floating-point) format.
*	@param	name	Optional user-specified filename (NULL for auto-generated).
*	@param	async	If true, encode/write on worker thread; if false, do on main thread.
*
*	Reads floating-point HDR pixels from framebuffer and saves in Radiance .hdr format.
*	Only available when renderer is in HDR mode. Captures full dynamic range for
*	post-processing or tonemapping.
*
*	@note	Warns if attempted when not in HDR mode.
**/
static void make_screenshot_hdr(const char *name, bool async)
{
    char        buffer[MAX_OSPATH];
    int         ret;
    FILE        *fp;

    if(!is_render_hdr()) {
        Com_WPrintf("Screenshot format supported in HDR mode only\n");
        return;
    }

    ret = create_screenshot(buffer, sizeof(buffer), &fp, name, ".hdr");
    if (ret < 0) {
        Com_EPrintf("Couldn't create HDR screenshot: %s\n", Q_ErrorString(ret));
        return;
    }

    screenshot_t s = {
        .save_cb = IMG_SaveHDR,
        .fp = fp,
        .filename = async ? Z_CopyString(buffer) : buffer,
        .status = -1,
        .param = 0,
        .async = async,
    };

    IMG_ReadPixelsHDR(&s);

    // Process HDR screenshot synchronously or queue for async processing
    if (async) {
        asyncwork_t work = {
            .work_cb = screenshot_work_cb,
            .done_cb = screenshot_done_cb,
            .cb_arg = Z_CopyStruct(&s),
        };
        Com_QueueAsyncWork(&work);
    } else {
        screenshot_work_cb(&s);
        screenshot_done_cb(&s);
    }
}

/**
*	@brief	Console command: Take a screenshot in default or specified format.
*
*	Usage: screenshot [format]
*	  format: h=HDR, j=JPG, p=PNG, t=TGA (default from r_screenshot_format)
*
*	Generates auto-numbered filename using template from gl_screenshot_template.
*	Format selection respects HDR mode - defaults to HDR if rendering in HDR mode.
**/
static void IMG_ScreenShot_f(void)
{
    const char *s;

    if (Cmd_Argc() > 2) {
        Com_Printf("Usage: %s [format]\n", Cmd_Argv(0));
        return;
    }

    if (Cmd_Argc() > 1) {
        s = Cmd_Argv(1);
    } else {
        if(is_render_hdr())
            s = "hdr";
        else
        s = r_screenshot_format->string;
    }

    if (*s == 'h') {
        make_screenshot_hdr(NULL, r_screenshot_async->integer > 0);
        return;
    }

    if (*s == 'j') {
        make_screenshot(NULL, ".jpg", IMG_SaveJPG,
                        r_screenshot_async->integer > 0,
                        r_screenshot_quality->integer);
        return;
    }

    if (*s == 'p') {
        make_screenshot(NULL, ".png", IMG_SavePNG,
                        r_screenshot_async->integer > 0,
                        r_screenshot_compression->integer);
        return;
    }

    make_screenshot(NULL, ".tga", IMG_SaveTGA, r_screenshot_async->integer > 0, 0);
}

/**
*	@brief	Console command: Take a TGA screenshot with optional custom name.
*
*	Usage: screenshottga [name]
*
*	If name is omitted, generates auto-numbered filename. TGA format is uncompressed
*	24-bit RGB, largest file size but fastest to write.
**/
static void IMG_ScreenShotTGA_f(void)
{
    if (Cmd_Argc() > 2) {
        Com_Printf("Usage: %s [name]\n", Cmd_Argv(0));
        return;
    }

    make_screenshot(Cmd_Argv(1), ".tga", IMG_SaveTGA, r_screenshot_async->integer > 0, 0);
}

/**
*	@brief	Console command: Take a JPEG screenshot with optional custom name and quality.
*
*	Usage: screenshotjpg [name] [quality]
*	  quality: 1-100 (default from gl_screenshot_quality, typically 100)
*
*	JPEG provides good compression for photographic content but loses quality.
*	Best for sharing screenshots where file size matters.
**/
static void IMG_ScreenShotJPG_f(void)
{
    int quality;

    if (Cmd_Argc() > 3) {
        Com_Printf("Usage: %s [name] [quality]\n", Cmd_Argv(0));
        return;
    }

    if (Cmd_Argc() > 2) {
        quality = atoi(Cmd_Argv(2));
    } else {
        quality = r_screenshot_quality->integer;
    }

    make_screenshot(Cmd_Argv(1), ".jpg", IMG_SaveJPG,
                    r_screenshot_async->integer > 0, quality);
}

/**
*	@brief	Console command: Take a PNG screenshot with optional custom name and compression.
*
*	Usage: screenshotpng [name] [compression]
*	  compression: 0-9 (default from gl_screenshot_compression, typically 6)
*
*	PNG provides lossless compression, good balance between file size and quality.
*	Higher compression takes longer but produces smaller files.
**/
static void IMG_ScreenShotPNG_f(void)
{
    int compression;

    if (Cmd_Argc() > 3) {
        Com_Printf("Usage: %s [name] [compression]\n", Cmd_Argv(0));
        return;
    }

    if (Cmd_Argc() > 2) {
        compression = atoi(Cmd_Argv(2));
    } else {
        compression = r_screenshot_compression->integer;
    }

    make_screenshot(Cmd_Argv(1), ".png", IMG_SavePNG,
                    r_screenshot_async->integer > 0, compression);
}

/**
*	@brief	Console command: Take an HDR screenshot with optional custom name.
*
*	Usage: screenshothdr [name]
*
*	Only available when rendering in HDR mode. Captures floating-point RGB values
*	in Radiance .hdr format, preserving full dynamic range for post-processing.
*
*	@note	Warns if not in HDR rendering mode.
**/
static void IMG_ScreenShotHDR_f(void)
{
    if (Cmd_Argc() > 2) {
        Com_Printf("Usage: %s [name]\n", Cmd_Argv(0));
        return;
    }

    make_screenshot_hdr(Cmd_Argv(1), r_screenshot_async->integer > 0);
}

/**
*
*
*
*	Image Processing (Resampling, Mipmaps):
*
*
*
**/

/**
*	@brief	Resample texture to different dimensions using bilinear filtering.
*	@param	in			Input image pixel data (32-bit RGBA).
*	@param	inwidth		Input image width.
*	@param	inheight	Input image height.
*	@param	out			Output buffer for resampled image.
*	@param	outwidth	Desired output width.
*	@param	outheight	Desired output height.
*
*	Performs high-quality texture resampling using a 4-sample bilinear filter.
*	Used for scaling textures to power-of-two dimensions or generating scaled
*	versions. Samples at quarter-points within each output pixel for better quality.
*
*	@note	outwidth must not exceed MAX_TEXTURE_SIZE.
*	@note	Uses fixed-point arithmetic for efficient coordinate mapping.
**/
void IMG_ResampleTexture(const byte *in, int inwidth, int inheight,
                         byte *out, int outwidth, int outheight)
{
    int i, j;
    const byte  *inrow1, *inrow2;
    unsigned    frac, fracstep;
    unsigned    p1[MAX_TEXTURE_SIZE], p2[MAX_TEXTURE_SIZE];
    const byte  *pix1, *pix2, *pix3, *pix4;
    float       heightScale;

    if (outwidth > MAX_TEXTURE_SIZE) {
        Com_Error(ERR_FATAL, "%s: outwidth > %d", __func__, MAX_TEXTURE_SIZE);
    }

    // Compute fixed-point step for horizontal sampling
    fracstep = inwidth * 0x10000 / outwidth;

    // Precompute sample positions at 1/4 and 3/4 points for bilinear filtering
    frac = fracstep >> 2;
    for (i = 0; i < outwidth; i++) {
        p1[i] = 4 * (frac >> 16);
        frac += fracstep;
    }
    frac = 3 * (fracstep >> 2);
    for (i = 0; i < outwidth; i++) {
        p2[i] = 4 * (frac >> 16);
        frac += fracstep;
    }

    heightScale = (float)inheight / outheight;
    inwidth <<= 2; // Convert to byte stride (4 bytes per pixel)
    // Sample at 1/4 and 3/4 vertical positions within each output row
    for (i = 0; i < outheight; i++) {
        inrow1 = in + inwidth * (int)((i + 0.25f) * heightScale);
        inrow2 = in + inwidth * (int)((i + 0.75f) * heightScale);
        for (j = 0; j < outwidth; j++) {
            // Sample 4 points in a box pattern and average
            pix1 = inrow1 + p1[j];
            pix2 = inrow1 + p2[j];
            pix3 = inrow2 + p1[j];
            pix4 = inrow2 + p2[j];
            // Average RGBA components (divide by 4 via right-shift 2)
            out[0] = (pix1[0] + pix2[0] + pix3[0] + pix4[0]) >> 2;
            out[1] = (pix1[1] + pix2[1] + pix3[1] + pix4[1]) >> 2;
            out[2] = (pix1[2] + pix2[2] + pix3[2] + pix4[2]) >> 2;
            out[3] = (pix1[3] + pix2[3] + pix3[3] + pix4[3]) >> 2;
            out += 4;
        }
    }
}

/**
*	@brief	Generate next mipmap level by averaging 2x2 pixel blocks.
*	@param	out		Output buffer for mipmap (1/4 size of input).
*	@param	in		Input image pixel data (32-bit RGBA).
*	@param	width	Input image width (halved for output).
*	@param	height	Input image height (halved for output).
*
*	Creates the next lower mipmap level by averaging each 2x2 block of pixels
*	from the input image. Output dimensions are width/2 x height/2. Used for
*	generating mipmaps to improve texture quality and performance.
*
*	@note	Input width and height should be even numbers.
*	@note	Operates on 32-bit RGBA pixel data (4 bytes per pixel).
**/
void IMG_MipMap(byte *out, byte *in, int width, int height)
{
    int     i, j;

    width <<= 2; // Convert to byte stride (4 bytes per pixel)
    height >>= 1; // Output height is half input height
    for (i = 0; i < height; i++, in += width) {
        for (j = 0; j < width; j += 8, out += 4, in += 8) {
            // Average 2x2 block: top-left, top-right, bottom-left, bottom-right
            out[0] = (in[0] + in[4] + in[width + 0] + in[width + 4]) >> 2;
            out[1] = (in[1] + in[5] + in[width + 1] + in[width + 5]) >> 2;
            out[2] = (in[2] + in[6] + in[width + 2] + in[width + 6]) >> 2;
            out[3] = (in[3] + in[7] + in[width + 3] + in[width + 7]) >> 2;
        }
    }
}

/**
*
*
*
*	Image Manager (Caching, Lookup):
*
*
*
**/

// Hash table size for image name lookup (power of 2)
#define RIMAGES_HASH    256

// Hash table for fast image lookup by name
static list_t   r_imageHash[RIMAGES_HASH];

// Global image registry (slot 0 is R_NOTEXTURE placeholder)
image_t     r_images[MAX_RIMAGES];
int         r_numImages;

// Palette conversion table: 8-bit index -> 32-bit RGBA
uint32_t    d_8to24table[256];

// Image format loader table: maps extensions to loader functions
static const struct {
    char    ext[4];
    int     (*load)(byte *, size_t, image_t *, byte **);
} img_loaders[IM_MAX] = {
    { "pcx", IMG_LoadPCX },
    { "wal", IMG_LoadWAL },
    { "tga", IMG_LoadSTB },
    { "jpg", IMG_LoadSTB },
    { "png", IMG_LoadSTB }
};

// Format search order (configured via r_texture_formats cvar)
static imageformat_t    img_search[IM_MAX];
static int              img_total;

static cvar_t   *r_override_textures;
static cvar_t   *r_texture_formats;
static cvar_t   *r_texture_overrides;

static const cmd_option_t o_imagelist[] = {
    { "f", "fonts", "list fonts" },
    { "h", "help", "display this help message" },
    { "m", "skins", "list skins" },
    { "p", "pics", "list pics" },
    { "P", "placeholder", "list placeholder images" },
    { "s", "sprites", "list sprites" },
    { "w", "walls", "list walls" },
    { "y", "skies", "list skies" },
    { "S:string", "save", "save list to file"},
    { NULL }
};

static void IMG_List_c(genctx_t *ctx, int argnum)
{
    Cmd_Option_c(o_imagelist, NULL, ctx, argnum);
}

/**
*	@brief	Console command: List all registered images with filtering options.
*
*	Usage: imagelist [options] [wildcard]
*	  Options: -f (fonts), -m (skins), -p (pics), -s (sprites), -w (walls), -y (skies)
*	           -P (placeholders), -S <file> (save to CSV)
*
*	Displays image registry with type, dimensions, flags, and format info.
*	Can filter by type and wildcard pattern.
**/
static void IMG_List_f(void)
{
    static const char types[8] = "PFMSWY??";
    image_t     *image;
    const char  *wildcard = NULL;
    bool        placeholder = false;
    int         i, c, mask = 0, count = 0;
    size_t      texels = 0;
    const char  *save_path = NULL;
    qhandle_t   f = 0;
    char        path[MAX_OSPATH];

    while ((c = Cmd_ParseOptions(o_imagelist)) != -1) {
        switch (c) {
        case 'p': mask |= 1 << IT_PIC;      break;
        case 'f': mask |= 1 << IT_FONT;     break;
        case 'm': mask |= 1 << IT_SKIN;     break;
        case 's': mask |= 1 << IT_SPRITE;   break;
        case 'w': mask |= 1 << IT_WALL;     break;
        case 'y': mask |= 1 << IT_SKY;      break;
        case 'P': placeholder = true;       break;
        case 'S': save_path = cmd_optarg;   break;
        case 'h':
            Cmd_PrintUsage(o_imagelist, "[wildcard]");
            Com_Printf("List registered images.\n");
            Cmd_PrintHelp(o_imagelist);
            Com_Printf(
                "Types legend:\n"
                "P: pics\n"
                "F: fonts\n"
                "M: skins\n"
                "S: sprites\n"
                "W: walls\n"
                "Y: skies\n"
                "\nFlags legend:\n"
                "T: transparent\n"
                "S: scrap\n"
                "*: permanent\n"
            );
            return;
        default:
            return;
        }
    }

    if (cmd_optind < Cmd_Argc())
        wildcard = Cmd_Argv(cmd_optind);

    if (save_path) {
        // save to file
        qhandle_t f = FS_EasyOpenFile(path, sizeof(path), FS_MODE_WRITE | FS_FLAG_TEXT, "", save_path, ".csv");
        if (!f) {
            Com_EPrintf("Error opening '%s'\n", path);
            return;
        }
    } else {
        Com_Printf("------------------\n");
    }

    for (i = 1, image = r_images + 1; i < r_numImages; i++, image++) {
        if (!image->registration_sequence)
            continue;
        if (mask && !(mask & (1 << image->type)))
            continue;
        if (wildcard && !Com_WildCmp(wildcard, image->name))
            continue;
        if ((image->width && image->height) == placeholder)
            continue;

        if (f) {
            char fmt[MAX_QPATH];
            sprintf(fmt, "%%-%ds, %%-%ds, (%% 5d %% 5d), sRGB:%%d\n", MAX_QPATH, MAX_QPATH);

            FS_FPrintf(f, fmt,
                image->name,
                image->filepath,
                image->width,
                image->height,
                image->is_srgb);
        } else {
            Com_Printf("%c%c%c%c %4i %4i %s: %s\n",
                    types[image->type > IT_MAX ? IT_MAX : image->type],
                    (image->flags & IF_TRANSPARENT) ? 'T' : ' ',
                    (image->flags & IF_SCRAP) ? 'S' : ' ',
                    (image->flags & IF_PERMANENT) ? '*' : ' ',
                    image->upload_width,
                    image->upload_height,
                    (image->flags & IF_PALETTED) ? "PAL" : "RGB",
                    image->name);
        }

        texels += image->upload_width * image->upload_height;
        count++;
    }

    if (f) {
        FS_CloseFile(f);
        Com_Printf("Saved '%s'\n", path);
    } else {
        Com_Printf("Total images: %d (out of %d slots)\n", count, r_numImages);
        Com_Printf("Total texels: %zu (not counting mipmaps)\n", texels);
    }
}

/**
*	@brief	Allocate a free image slot from the global registry.
*	@return	Pointer to allocated image_t structure, or NULL if registry is full.
*
*	Searches for free slots in this order:
*	1. Unregistered slots (registration_sequence == 0)
*	2. Placeholder images (zero dimensions, failed loads)
*	3. New slot if under MAX_RIMAGES limit
*
*	Slot 0 is reserved for R_NOTEXTURE, so search starts at index 1.
**/
static image_t *alloc_image(void)
{
    int i;
    image_t *image, *placeholder = NULL;

    // Find a free image_t slot (skip slot 0, reserved for R_NOTEXTURE)
    for (i = 1, image = r_images + 1; i < r_numImages; i++, image++) {
        if (!image->registration_sequence)
            return image;
        // Remember first placeholder as fallback
        if (!image->upload_width && !image->upload_height && !placeholder)
            placeholder = image;
    }

    // Allocate new slot if registry not full
    if (r_numImages < MAX_RIMAGES) {
        r_numImages++;
        return image;
    }

    // Reuse placeholder image as last resort
    if (placeholder) {
        List_Remove(&placeholder->entry);
        memset(placeholder, 0, sizeof(*placeholder));
        return placeholder;
    }

    return NULL;
}

/**
*	@brief	Look up an image in the hash table by name and type.
*	@param	name	Image name (with extension).
*	@param	type	Image type (IT_PIC, IT_SKIN, IT_WALL, etc.).
*	@param	hash	Precomputed hash value for lookup.
*	@param	baselen	Length of name excluding extension.
*	@return	Pointer to existing image, or NULL if not found.
*
*	Performs hash-based lookup with case-insensitive and extension-insensitive
*	name comparison. Only matches images of the specified type.
**/
static image_t *lookup_image(const char *name,
                             imagetype_t type, unsigned hash, size_t baselen)
{
    image_t *image;

    // Search hash bucket for matching image
    LIST_FOR_EACH(image_t, image, &r_imageHash[hash], entry) {
        if (image->type != type) {
            continue;
        }
        if (image->baselen != baselen) {
            continue;
        }
        // Compare basename only (extension-insensitive)
        if (!FS_pathcmpn(image->name, name, baselen)) {
            return image;
        }
    }

    return NULL;
}

#define TRY_IMAGE_SRC_GAME      1
#define TRY_IMAGE_SRC_BASE      0

static int _try_image_format(imageformat_t fmt, image_t *image, int try_src, byte **pic)
{
    byte        *data;
    int         len;
    int         ret;

    // load the file
    int fs_flags = 0;
    if (try_src > 0)
        fs_flags = try_src == TRY_IMAGE_SRC_GAME ? FS_PATH_GAME : FS_PATH_BASE;
    len = FS_LoadFileFlags(image->name, (void **)&data, fs_flags);
    if (!data) {
        return len;
    }

    // decompress the image
    ret = img_loaders[fmt].load(data, len, image, pic);
    
    FS_FreeFile(data);

    image->filepath[0] = 0;
    if (ret >= 0) {
        strcpy(image->filepath, image->name);
        // record last modified time (skips reload when invoking IMG_ReloadAll)
        image->last_modified = 0;
        FS_LastModified(image->filepath, &image->last_modified);
    }
    return ret < 0 ? ret : fmt;
}

static int try_image_format(imageformat_t fmt, image_t *image, int try_src, byte **pic)
{
    // replace the extension
    memcpy(image->name + image->baselen + 1, img_loaders[fmt].ext, 4);
    return _try_image_format(fmt, image, try_src, pic);
}


/**
*	@brief	Attempt to load image with alternate formats in priority order.
*	@param	orig	Original format to skip (already tried).
*	@param	image	Image structure with base name set.
*	@param	try_src	Source location flag (TRY_IMAGE_SRC_GAME or TRY_IMAGE_SRC_BASE).
*	@param	pic		Output parameter for pixel data.
*	@return	Format ID on success, error code on failure.
*
*	Searches through configured format priority list (img_search), trying each
*	extension. Falls back to 8-bit formats (WAL for walls, PCX for others) if
*	no 32-bit format is found.
**/
static int try_other_formats(imageformat_t orig, image_t *image, int try_src, byte **pic)
{
    imageformat_t   fmt;
    int             ret;
    int             i;

    // search through all the 32-bit formats
    for (i = 0; i < img_total; i++) {
        fmt = img_search[i];
        if (fmt == orig) {
            continue;   // don't retry twice
        }

        ret = try_image_format(fmt, image, try_src, pic);
        if (ret != Q_ERR(ENOENT)) {
            return ret; // found something
        }
    }

    // fall back to 8-bit formats
    fmt = (image->type == IT_WALL) ? IM_WAL : IM_PCX;
    if (fmt == orig) {
        return Q_ERR(ENOENT); // don't retry twice
    }

    return try_image_format(fmt, image, try_src, pic);
}

/**
*	@brief	Read image dimensions without loading full pixel data.
*	@param	name	Image file path.
*	@param	width	Output parameter for image width.
*	@param	height	Output parameter for image height.
*	@return	Q_ERR_SUCCESS on success, error code on failure.
*
*	Efficiently reads just the header of PCX or WAL files to extract dimensions.
*	Useful for reserving memory or validating image properties before full load.
*
*	@note	Only supports PCX and WAL formats.
**/
int IMG_GetDimensions(const char* name, int* width, int* height)
{
    assert(name);
    assert(width);
    assert(height);
    
    int w = 0;
    int h = 0;

    ssize_t len = strlen(name);
    if (len <= 4)
        return Q_ERR_NAMETOOSHORT;

    imageformat_t format;

    if (Q_stricmp(name + len - 4, ".wal") == 0)
        format = IM_WAL;
    else if (Q_stricmp(name + len - 4, ".pcx") == 0)
        format = IM_PCX;
    else
        return Q_ERR_INVALID_FORMAT;

    qhandle_t f;
    FS_OpenFile(name, &f, FS_MODE_READ | FS_FLAG_LOADFILE);
    if (!f)
        return Q_ERR(ENOENT);

    if (format == IM_WAL)
    {
        miptex_t mt;
        len = FS_Read(&mt, sizeof(mt), f);
        if (len == sizeof(mt)) {
            w = LittleLong(mt.width);
            h = LittleLong(mt.height);
        }
    }
    else if (format == IM_PCX)
    {
        dpcx_t pcx;
        len = FS_Read(&pcx, sizeof(pcx), f);
        if (len == sizeof(pcx)) {
            w = (LittleShort(pcx.xmax) - LittleShort(pcx.xmin)) + 1;
            h = (LittleShort(pcx.ymax) - LittleShort(pcx.ymin)) + 1;
        }
    }

    FS_CloseFile(f);

    if (w < 1 || h < 1 || w > MAX_TEXTURE_SIZE || h > MAX_TEXTURE_SIZE) {
        return Q_ERR_INVALID_FORMAT;
    }

    *width = w;
    *height = h;

    return Q_ERR_SUCCESS;
}

static void get_image_dimensions(imageformat_t fmt, image_t *image)
{
    char buffer[MAX_QPATH];
    memcpy(buffer, image->name, image->baselen + 1);
    memcpy(buffer + image->baselen + 1, img_loaders[fmt].ext, 4);

    IMG_GetDimensions(buffer, &image->width, &image->height);
}

/**
*	@brief	Cvar callback: Parse r_texture_formats string to set format priority.
*	@param	self	The r_texture_formats cvar.
*
*	Configures search order for texture formats based on string like "tpj" (TGA, PNG, JPG).
*	Letters: t=TGA, p=PNG, j=JPG. Order determines which format is tried first when
*	loading textures with override system.
**/
static void r_texture_formats_changed(cvar_t *self)
{
    char *s;
    int i, j;

    // reset the search order
    img_total = 0;

    // parse the string
    for (s = self->string; *s; s++) {
        switch (*s) {
            case 't': case 'T': i = IM_TGA; break;
            case 'j': case 'J': i = IM_JPG; break;
            case 'p': case 'P': i = IM_PNG; break;
            default: continue;
        }

        // don't let format to be specified more than once
        for (j = 0; j < img_total; j++)
            if (img_search[j] == i)
                break;
        if (j != img_total)
            continue;

        img_search[img_total++] = i;
        if (img_total == IM_MAX) {
            break;
        }
    }
}

/**
*	@brief	Load an image file by exact name (internal/legacy function).
*	@param	name	Full image path with extension.
*	@param	image	Image structure to populate.
*	@return	Q_ERR_SUCCESS on success, error code on failure.
*
*	Direct image loading without override system. Tries original format first,
*	then searches alternate formats. Used for explicit image loading requests.
*
*	@note	Prefer find_or_load_image() for normal loading with caching/overrides.
**/
int
load_img(const char *name, image_t *image)
{
    byte            *pic;
    imageformat_t   fmt;
    int             ret = Q_ERR(EINVAL);

	size_t len = strlen(name);

    // must have an extension and at least 1 char of base name
    if (len <= 4) {
        return Q_ERR_NAMETOOSHORT;
    }
    if (name[len - 4] != '.') {
        return Q_ERR_INVALID_PATH;
    }

    memcpy(image->name, name, len + 1);
    image->baselen = len - 4;
    image->type = 0;
    image->flags = 0;
    image->registration_sequence = 1;

    // find out original extension
    for (fmt = 0; fmt < IM_MAX; fmt++) {
        if (!Q_stricmp(image->name + image->baselen + 1, img_loaders[fmt].ext)) {
            break;
        }
    }

    // load the pic from disk
    pic = NULL;

    // Always prefer images from the game dir, even if format might be 'inferior'
    for (int try_location = Q_stricmp(fs_game->string, BASEGAME) ? TRY_IMAGE_SRC_GAME : TRY_IMAGE_SRC_BASE;
         try_location >= TRY_IMAGE_SRC_BASE;
         try_location--)
    {
        int location_flag = try_location == TRY_IMAGE_SRC_GAME ? IF_SRC_GAME : IF_SRC_MASK;
        if(((image->flags & IF_SRC_MASK) != 0) && ((image->flags & IF_SRC_MASK) != location_flag))
            continue;

        // first try with original extension
        ret = _try_image_format(fmt, image, try_location, &pic);
        if (ret == Q_ERR(ENOENT)) {
            // retry with remaining extensions
            ret = try_other_formats(fmt, image, try_location, &pic);
        }
        if (ret >= 0)
            break;
    }

    // if we are replacing 8-bit texture with a higher resolution 32-bit
    // texture, we need to recover original image dimensions
    if (fmt <= IM_WAL && ret > IM_WAL) {
        get_image_dimensions(fmt, image);
    }

    if (ret < 0) {
        memset(image, 0, sizeof(*image));
        return ret;
    }

#if USE_REF == REF_VKPT
	image->pix_data = pic;
#endif

    return Q_ERR_SUCCESS;
}

static bool need_override_image(imagetype_t type, imageformat_t fmt)
{
    if (r_override_textures->integer < 1)
        return false;
    if (r_override_textures->integer == 1 && fmt > IM_WAL)
        return false;
    return r_texture_overrides->integer & (1 << type);
}

/**
*	@brief	Attempt to load an image with format and override system applied.
*	@param	image			Image structure with name set.
*	@param	orig_name		Original name to restore after override attempt (or NULL).
*	@param	orig_len		Length of original name.
*	@param	pic_p			Output parameter for pixel data.
*	@param	type			Image type (IT_PIC, IT_SKIN, etc.).
*	@param	flags			Image flags (IF_EXACT, IF_PERMANENT, etc.).
*	@param	allow_override	Whether to try HD asset overrides.
*	@param	try_location	Source location (TRY_IMAGE_SRC_GAME or TRY_IMAGE_SRC_BASE).
*	@return	Format ID on success, error code on failure.
*
*	Core loading logic with support for:
*	- Format priority and override system (r_override_textures, r_texture_formats)
*	- HD asset replacement from overrides/ directory
*	- Fallback to 8-bit formats if 32-bit not available
*	- IF_EXACT flag to disable format substitution
**/
static int try_load_image_candidate(image_t *image, const char *orig_name, size_t orig_len, byte **pic_p, imagetype_t type, imageflags_t flags, bool allow_override, int try_location)
{
    int ret;

    image->type = type;
    image->flags = flags;
    image->registration_sequence = registration_sequence;

    // Determine original extension from image name
    imageformat_t fmt;
    for (fmt = 0; fmt < IM_MAX; fmt++)
    {
        if (!Q_stricmp(image->name + image->baselen + 1, img_loaders[fmt].ext))
        {
            break;
        }
    }

    // Check if texture override system should be used (HD assets)
    bool override_texture = !allow_override || (flags & IF_EXACT) ? false : need_override_image(type, fmt);

    // Load pixel data from disk
    *pic_p = NULL;

    if (fmt == IM_MAX)
    {
        // Unknown extension - try all formats as fallback
        ret = try_other_formats(IM_MAX, image, try_location, pic_p);
        if (ret == Q_ERR(ENOENT))
        {
            // not found, change error to invalid path
            ret = Q_ERR_INVALID_PATH;
        }
    }
    else if (override_texture)
    {
        // Override mode: forcibly try higher-quality formats first
        ret = try_other_formats(IM_MAX, image, try_location, pic_p);
    }
    else
    {
        // Normal mode: try original extension first
        ret = _try_image_format(fmt, image, try_location, pic_p);
        if (ret == Q_ERR(ENOENT) && !(flags & IF_EXACT))
        {
            // Original not found - try alternate formats
            ret = try_other_formats(fmt, image, try_location, pic_p);
        }
    }

    // record last modified time (skips reload when invoking IMG_ReloadAll)
    image->last_modified = 0;
    FS_LastModified(image->name, &image->last_modified);

    // Restore original name if it was overridden (for HD asset attempt)
    if(orig_name) {
        memcpy(image->name, orig_name, orig_len + 1);
        image->baselen = orig_len - 4;
    }

    // If we loaded a 32-bit texture as replacement for 8-bit original,
    // recover the original dimensions for compatibility
    if (fmt <= IM_WAL && ret > IM_WAL)
    {
        get_image_dimensions(fmt, image);
    }

    return ret;
}

static void print_error(const char *name, imageflags_t flags, int err)
{
    const char *msg;
    int level = PRINT_ERROR;

    switch (err) {
    case Q_ERR_INVALID_FORMAT:
    case Q_ERR_LIBRARY_ERROR:
        msg = Com_GetLastError();
        break;
    case Q_ERR(ENOENT):
        if (flags & IF_PERMANENT) {
            // ugly hack for console code
            if (strcmp(name, "pics/conchars.pcx"))
                level = PRINT_WARNING;
#if USE_DEBUG
        } else if (developer->integer >= 2) {
            level = PRINT_DEVELOPER;
#endif
        } else {
            return;
        }
        // fall through
    default:
        msg = Q_ErrorString(err);
        break;
    }

    Com_LPrintf(level, "Couldn't load %s: %s\n", name, msg);
}

/**
*	@brief	Find existing image or load from disk, with full caching and override system.
*	@param	name	Image name with extension.
*	@param	len		Length of name string.
*	@param	type	Image type (IT_PIC, IT_SKIN, IT_WALL, etc.).
*	@param	flags	Image flags (IF_PERMANENT, IF_EXACT, IF_SRGB, etc.).
*	@return	Pointer to image structure, or NULL on failure.
*
*	Main image loading pipeline with features:
*	- Hash-based caching (returns existing image if already loaded)
*	- Placeholder handling (returns NULL for failed previous loads)
*	- HD asset override system (tries overrides/ directory first)
*	- Multi-source loading (game directory preferred over baseq2)
*	- Format fallback and priority system
*	- Automatic slot allocation and hash table insertion
*
*	@note	This is the primary entry point for image loading.
**/
static image_t *find_or_load_image(const char *name, size_t len,
                                   imagetype_t type, imageflags_t flags)
{
    image_t         *image;
    byte            *pic;
    unsigned        hash;
    int             ret = Q_ERR(ENOENT);

    // must have an extension and at least 1 char of base name
    if (len <= 4) {
        ret = Q_ERR_NAMETOOSHORT;
        goto fail;
    }
    if (name[len - 4] != '.') {
        ret = Q_ERR_INVALID_PATH;
        goto fail;
    }

    hash = FS_HashPathLen(name, len - 4, RIMAGES_HASH);

    // Check if image already loaded (cache hit)
    if ((image = lookup_image(name, type, hash, len - 4)) != NULL) {
        image->registration_sequence = registration_sequence;
        if (image->upload_width && image->upload_height) {
            // Valid cached image
            image->flags |= flags & IF_PERMANENT;
            return image;
        }
        // Placeholder from previous failed load
        return NULL;
    }

    // Allocate new image slot
    image = alloc_image();
    if (!image) {
        ret = Q_ERR_OUT_OF_SLOTS;
        goto fail;
    }

    // HD asset overrides enabled for VKPT or if gl_use_hd_assets is set
    bool allow_override = cls.ref_type != REF_TYPE_GL || type == IT_PIC || gl_use_hd_assets->integer;

    // Try loading from overrides/ directory first (HD asset replacement)
    if(allow_override)
    {
        const char *last_slash = strrchr(name, '/');
        if (!last_slash)
            last_slash = name;
        else
            last_slash += 1;

        strcpy(image->name, "overrides/");
        strcat(image->name, last_slash);
        image->baselen = strlen(image->name) - 4;
        ret = try_load_image_candidate(image, name, len, &pic, type, flags, true, -1);
        memcpy(image->name, name, len + 1);
        image->baselen = len - 4;
    }

    // Try loading from standard paths (game dir, then baseq2)
    if (ret < 0)
    {
        bool is_not_baseq2 = fs_game->string[0] && strcmp(fs_game->string, BASEGAME) != 0;
    	
        // Prefer mod directory over baseq2, even if mod has "inferior" format
        for (int try_location = is_not_baseq2 ? TRY_IMAGE_SRC_GAME : TRY_IMAGE_SRC_BASE;
            try_location >= TRY_IMAGE_SRC_BASE;
            try_location--)
        {
            int location_flag = try_location == TRY_IMAGE_SRC_GAME ? IF_SRC_GAME : IF_SRC_BASE;
            if(((flags & IF_SRC_MASK) != 0) && ((flags & IF_SRC_MASK) != location_flag))
                continue;

            // fill in some basic info
            memcpy(image->name, name, len + 1);
            image->baselen = len - 4;
            ret = try_load_image_candidate(image, NULL, 0, &pic, type, flags, !!allow_override, try_location);
            image->flags |= location_flag;

            if (ret >= 0)
                break;
        }
    }

    if (ret < 0) {
        print_error(image->name, flags, ret);
        if (flags & IF_PERMANENT) {
            // Permanent image failed - free slot
            memset(image, 0, sizeof(*image));
        } else {
            // Temporary image failed - create placeholder to avoid retrying every frame
            image->upload_width = image->upload_height = 0;
            List_Append(&r_imageHash[hash], &image->entry);
        }
        return NULL;
    }

    // Calculate aspect ratio for UI rendering
    image->aspect = (float)image->upload_width / image->upload_height;

    // Insert into hash table for fast lookup
    List_Append(&r_imageHash[hash], &image->entry);

	// Apply sRGB flag if requested
	image->is_srgb = !!(flags & IF_SRGB);

    // Upload to GPU via renderer-specific backend
    IMG_Load(image, pic);

    return image;

fail:
    print_error(name, flags, ret);
    return NULL;
}

/**
*	@brief	Find or load an image by name.
*	@param	name	Image name with extension.
*	@param	type	Image type (IT_PIC, IT_SKIN, IT_WALL, etc.).
*	@param	flags	Image flags (IF_PERMANENT, IF_EXACT, IF_SRGB, etc.).
*	@return	Pointer to image structure, or R_NOTEXTURE on failure.
*
*	Primary public API for finding/loading images. Returns R_NOTEXTURE placeholder
*	if image fails to load, ensuring callers always get a valid image pointer.
**/
image_t *IMG_Find(const char *name, imagetype_t type, imageflags_t flags)
{
    image_t *image;
    size_t len;

    Q_assert(name);

    len = strlen(name);
    Q_assert(len < MAX_QPATH);

    if ((image = find_or_load_image(name, len, type, flags))) {
        return image;
    }
    return R_NOTEXTURE;
}

/**
*	@brief	Look up an already-loaded image without attempting to load.
*	@param	name	Image name with extension.
*	@param	type	Image type to match.
*	@return	Pointer to existing image, or R_NOTEXTURE if not found.
*
*	Fast lookup that only searches the cache, never loads from disk.
*	Useful for checking if an image is already loaded.
**/
image_t *IMG_FindExisting(const char *name, imagetype_t type)
{
    image_t *image;
    size_t len;
    unsigned hash;

    if (!name) {
        Com_Error(ERR_FATAL, "%s: NULL", __func__);
        return R_NOTEXTURE;
    }

    // this should never happen
    len = strlen(name);
    if (len >= MAX_QPATH) {
        Com_Error(ERR_FATAL, "%s: oversize name", __func__);
        return R_NOTEXTURE;
    }

    // must have an extension and at least 1 char of base name
    if (len <= 4) {
        return R_NOTEXTURE;
    }
    if (len > 4 && name && name[len - 4] != '.') {
        return R_NOTEXTURE;
    }

    hash = FS_HashPathLen(name, len - 4, RIMAGES_HASH);

    // look for it
    if ((image = lookup_image(name, type, hash, len - 4)) != NULL) {
        return image;
    }

    return R_NOTEXTURE;
}

/**
*	@brief	Clone an existing image with optional new name.
*	@param	image		Image to clone.
*	@param	new_name	New name for cloned image (or NULL to keep same name).
*	@return	Pointer to cloned image, or R_NOTEXTURE on failure.
*
*	Creates a duplicate image with its own pixel data copy. Useful for creating
*	modified versions of textures or registering same texture under different names.
*
*	@note	VKPT path: copies pix_data. GL path: copies all mipmap levels.
**/
image_t *IMG_Clone(image_t *image, const char* new_name)
{
    if(image == R_NOTEXTURE)
        return image;

    image_t* new_image = alloc_image();
    if (!new_image)
        return R_NOTEXTURE;

    memcpy(new_image, image, sizeof(image_t));

#if USE_REF == REF_VKPT
    size_t image_size = image->upload_width * image->upload_height * 4;
    if(image->pix_data != NULL)
    {
        new_image->pix_data = IMG_AllocPixels(image_size);
        memcpy(new_image->pix_data, image->pix_data, image_size);
    }
#else
    for (int m = 0; m < 4; m++)
    {
        if(image->pixels[m] != NULL)
        {
            size_t mip_size = (image->upload_width >> m) * (image->upload_height >> m) * 4;
            new_image->pixels[m] = IMG_AllocPixels(mip_size);
            memcpy(new_image->pixels[m], image->pixels[m], mip_size);
        }
    }
#endif

    if(new_name)
    {
        Q_strlcpy(new_image->name, new_name, sizeof(new_image->name));
        new_image->baselen = strlen(new_image->name) - 4;
        assert(new_image->name[new_image->baselen] == '.');
    }
    unsigned hash = FS_HashPathLen(new_image->name, new_image->baselen, RIMAGES_HASH);
    List_Append(&r_imageHash[hash], &new_image->entry);
    return new_image;
}

/**
*	@brief	Convert image handle to image pointer.
*	@param	h	Image handle (index into r_images array).
*	@return	Pointer to image structure.
*
*	Simple handle-to-pointer conversion with bounds checking assertion.
*	Handles are integer indices used by game code and network protocol.
**/
image_t *IMG_ForHandle(qhandle_t h)
{
    Q_assert(h >= 0 && h < r_numImages);
    return &r_images[h];
}

/**
*	@brief	Register an image for rendering, with path normalization.
*	@param	name	Image name (extension optional, "pics/" prefix optional).
*	@param	type	Image type (IT_PIC, IT_SKIN, IT_WALL, etc.).
*	@param	flags	Image flags (IF_PERMANENT, IF_SRGB, etc.).
*	@return	Image handle (qhandle_t), or 0 on failure.
*
*	Public registration API with automatic path handling:
*	- Empty names return 0 (no error)
*	- IT_SKIN: uses name as-is
*	- Other types: strips leading slash, adds "pics/" prefix, adds ".pcx" extension
*
*	Returns handle (integer index) suitable for network transmission and saving.
**/
qhandle_t R_RegisterImage(const char *name, imagetype_t type, imageflags_t flags)
{
    image_t     *image;
    char        fullname[MAX_QPATH];
    size_t      len;

    // empty names are legal, silently ignore them
    if (!*name) {
        return 0;
    }

    // no images = not initialized
    if (!r_numImages) {
        return 0;
    }

    if (type == IT_SKIN) {
        len = FS_NormalizePathBuffer(fullname, name, sizeof(fullname));
    } else if (*name == '/' || *name == '\\') {
        len = FS_NormalizePathBuffer(fullname, name + 1, sizeof(fullname));
    } else {
        len = Q_concat(fullname, sizeof(fullname), "pics/", name);
        if (len < sizeof(fullname)) {
            FS_NormalizePath(fullname);
            len = COM_DefaultExtension(fullname, ".pcx", sizeof(fullname));
        }
    }

    if (len >= sizeof(fullname)) {
        print_error(fullname, flags, Q_ERR(ENAMETOOLONG));
        return 0;
    }

    if ((image = find_or_load_image(fullname, len, type, flags))) {
        return image - r_images;
    }
    return 0;
}

/**
*	@brief	Register raw pixel data as an image without loading from disk.
*	@param	name	Image name (for lookup/identification).
*	@param	width	Image width in pixels.
*	@param	height	Image height in pixels.
*	@param	pic		Raw pixel data (32-bit RGBA).
*	@param	type	Image type.
*	@param	flags	Image flags.
*	@return	Image handle, or 0 on failure.
*
*	Creates an image from in-memory pixel data, bypassing file loading.
*	Used for procedurally generated textures, scrap atlases, and dynamic content.
*
*	@note	Checks cache first - returns existing image if name already registered.
**/
qhandle_t R_RegisterRawImage(const char *name, int width, int height, byte* pic, imagetype_t type, imageflags_t flags)
{
    image_t         *image;
    unsigned        hash;

    int len = strlen(name);
    hash = FS_HashPathLen(name, len, RIMAGES_HASH);

    // look for it
    if ((image = lookup_image(name, type, hash, len)) != NULL) {
        image->flags |= flags & IF_PERMANENT;
        image->registration_sequence = registration_sequence;
        return image - r_images;
    }

    // allocate image slot
    image = alloc_image();
    if (!image) {
        return 0;
    }

    memcpy(image->name, name, len + 1);
    image->baselen = len;
    image->type = type;
    image->flags = flags;
    image->registration_sequence = registration_sequence;
    image->last_modified = 0;
    image->width = width;
    image->height = height;
    image->upload_width = width;
    image->upload_height = height;

    List_Append(&r_imageHash[hash], &image->entry);

    image->is_srgb = !!(flags & IF_SRGB);

    // upload the image
    IMG_Load(image, pic);

    return image - r_images;
}

/**
*	@brief	Unregister an image and free it immediately if not marked permanent.
*	@param	handle	Image handle to unregister.
*
*	Marks image for immediate cleanup by setting negative registration sequence
*	and calling IMG_FreeUnused(). Only affects non-permanent images.
**/
void R_UnregisterImage(qhandle_t handle)
{
    if (!handle)
        return;

    image_t* image = r_images + handle;

    if (image->registration_sequence)
    {
        // Negative sequence triggers immediate cleanup
        image->registration_sequence = -1;
        IMG_FreeUnused();
    }
}

/**
*	@brief	Get dimensions and transparency flag for a registered pic.
*	@param	w	Output parameter for width (or NULL).
*	@param	h	Output parameter for height (or NULL).
*	@param	pic	Image handle.
*	@return	True if image has transparency, false if opaque.
*
*	Retrieves display dimensions and transparency info for UI rendering.
*	Used by 2D drawing code to properly render HUD elements and menus.
**/
bool R_GetPicSize(int *w, int *h, qhandle_t pic)
{
    image_t *image = IMG_ForHandle(pic);

    if (w) {
        *w = image->width;
    }
    if (h) {
        *h = image->height;
    }
    return image->flags & IF_TRANSPARENT;
}

/**
*	@brief	Free all images not used in current registration sequence.
*
*	Called at end of level load to free unused images. Images touched during
*	current registration_sequence are kept. Permanent and scrap images are
*	never freed. Cleans up placeholder images from failed loads.
*
*	@note	Part of Quake 2's automatic memory management - levels register
*	        needed assets, then this frees everything else.
**/
void IMG_FreeUnused(void)
{
    image_t *image;
    int i, count = 0;

    for (i = 1, image = r_images + 1; i < r_numImages; i++, image++) {
        if (image->registration_sequence == registration_sequence) {
            continue;        // Used this sequence - keep it
        }
        if (!image->registration_sequence)
            continue;        // Already free
        if (image->flags & (IF_PERMANENT | IF_SCRAP))
            continue;        // Never free permanent or scrap images

        // Remove from hash table
        List_Remove(&image->entry);

        // Free GPU resources via renderer backend
        IMG_Unload(image);

        memset(image, 0, sizeof(*image));
        count++;
    }

    if (count) {
        Com_DPrintf("%s: %i images freed\n", __func__, count);
    }
}

/**
*	@brief	Free all images including permanent ones.
*
*	Complete image system reset, typically called during shutdown or when
*	switching renderers. Frees all GPU resources, clears hash table, and
*	resets registry to initial state (only R_NOTEXTURE in slot 0).
*
*	@note	More aggressive than IMG_FreeUnused() - frees even permanent images.
**/
void IMG_FreeAll(void)
{
    image_t *image;
    int i, count = 0;

    for (i = 1, image = r_images + 1; i < r_numImages; i++, image++) {
        if (!image->registration_sequence)
            continue;        // Already free
        // Free GPU resources
        IMG_Unload(image);

        memset(image, 0, sizeof(*image));
        count++;
    }

    if (count) {
        Com_DPrintf("%s: %i images freed\n", __func__, count);
    }

    // Reset all hash buckets
    for (i = 0; i < RIMAGES_HASH; i++) {
        List_Init(&r_imageHash[i]);
    }

    // Reset to initial state: r_images[0] is R_NOTEXTURE placeholder
    r_numImages = 1;
}

/**
*	@brief	Load Quake 2 palette from colormap.pcx.
*
*	Extracts the 256-color palette used for 8-bit to 32-bit color conversion.
*	Palette is stored in d_8to24table as 32-bit RGBA values, with index 255
*	set to transparent (alpha=0) and all others opaque (alpha=255).
*
*	@note	Fatal error if colormap.pcx cannot be loaded.
*	@note	Palette is used by IMG_Unpack8() for all 8-bit texture conversions.
**/
void IMG_GetPalette(void)
{
    byte        pal[768], *src, *data;
    int         i, ret, len;

    // Load palette file
    len = FS_LoadFile(R_COLORMAP_PCX, (void **)&data);
    if (!data) {
        ret = len;
        goto fail;
    }

    // Extract 768-byte RGB palette from end of PCX file
    ret = IMG_DecodePCX(data, len, NULL, pal, NULL, NULL);

    FS_FreeFile(data);

    if (ret < 0) {
        goto fail;
    }

    // Convert RGB palette to 32-bit RGBA (indices 0-254 get alpha=255)
    for (i = 0, src = pal; i < 255; i++, src += 3) {
        d_8to24table[i] = MakeColor(src[0], src[1], src[2], 255);
    }

    // Index 255 is the transparent color marker (alpha=0)
    d_8to24table[i] = MakeColor(src[0], src[1], src[2], 0);
    return;

fail:
    Com_Error(ERR_FATAL, "Couldn't load %s: %s", R_COLORMAP_PCX, Q_ErrorString(ret));
}

/**
*
*
*
*	Initialization and Shutdown:
*
*
*
**/

// Console commands registry
static const cmdreg_t img_cmd[] = {
    { "imagelist", IMG_List_f, IMG_List_c },
    { "screenshot", IMG_ScreenShot_f },
    { "screenshottga", IMG_ScreenShotTGA_f },
    { "screenshotjpg", IMG_ScreenShotJPG_f },
    { "screenshotpng", IMG_ScreenShotPNG_f },
    { "screenshothdr", IMG_ScreenShotHDR_f },
    { NULL }
};

/**
*	@brief	Initialize the image loading and management system.
*
*	Sets up:
*	- Console variables for texture formats, overrides, and screenshots
*	- Console commands for image listing and screenshots
*	- Hash table for image caching
*	- Initial state with R_NOTEXTURE in slot 0
*
*	@note	Must be called before any image operations.
*	@note	r_numImages starts at 1 (slot 0 reserved for R_NOTEXTURE).
**/
void IMG_Init(void)
{
    int i;

    Q_assert(!r_numImages);

    // Texture override and format selection
    r_override_textures = Cvar_Get("r_override_textures", "1", CVAR_FILES);
    r_texture_formats = Cvar_Get("r_texture_formats", "tpj", 0);
    r_texture_formats->changed = r_texture_formats_changed;
    r_texture_formats_changed(r_texture_formats); // Parse initial value
    r_texture_overrides = Cvar_Get("r_texture_overrides", "-1", CVAR_FILES);

    // Screenshot configuration
    r_screenshot_format = Cvar_Get("gl_screenshot_format", "png", CVAR_ARCHIVE);
    r_screenshot_async = Cvar_Get("gl_screenshot_async", "1", 0);
    r_screenshot_quality = Cvar_Get("gl_screenshot_quality", "100", CVAR_ARCHIVE);
    r_screenshot_compression = Cvar_Get("gl_screenshot_compression", "6", CVAR_ARCHIVE);
    r_screenshot_message = Cvar_Get("gl_screenshot_message", "0", CVAR_ARCHIVE);
    r_screenshot_template = Cvar_Get("gl_screenshot_template", "quakeXXX", 0);

    // Register console commands
    Cmd_Register(img_cmd);

    // Initialize hash table buckets
    for (i = 0; i < RIMAGES_HASH; i++) {
        List_Init(&r_imageHash[i]);
    }

    // Start with slot 0 as R_NOTEXTURE placeholder
    r_numImages = 1;
}

/**
*	@brief	Shutdown the image system and unregister console commands.
*
*	Cleanup function called during renderer shutdown. Unregisters console
*	commands and marks system as uninitialized.
*
*	@note	Should call IMG_FreeAll() before this to free GPU resources.
**/
void IMG_Shutdown(void)
{
    Cmd_Deregister(img_cmd);
    r_numImages = 0;
}
