/********************************************************************
*
*
*	ClientGame: (Entity/Player State) -Events:
*
*
********************************************************************/
#include "clgame/clg_local.h"
#include "clgame/clg_entities.h"
#include "clgame/clg_events.h"
#include "clgame/clg_events_entities.h"
#include "clgame/clg_events_player.h"

// Needed:
#include "sharedgame/sg_entity_events.h"
#include "sharedgame/sg_entity_flags.h"
#include "sharedgame/sg_entity_types.h"



/**
*
*
*
*   Core Entity Event Handling:
*
*
*
**/
/**
*   @brief  Check if it is a player entity and acquire the clientNumber as well as the clientInfo.
**/
static const bool DecodeClientInfoFromEntityState( const entity_state_t *entityState, int32_t &outClientNumber, clientinfo_t **outClientInfo ) {
    // Default outputs.
    outClientNumber = -1;
    *outClientInfo = nullptr;

    // Is it a player model?
    if ( entityState->modelindex == MODELINDEX_PLAYER ) {
        // Decode the skinnum properties because we're dealing with a player model entity here.
        encoded_skinnum_t skinnum = static_cast<encoded_skinnum_t>( entityState->skinnum );
        // It's a player model, so decode the client number from skinnum.
        outClientNumber = skinnum.clientNumber;
        // Invalid client number by skin.
        if ( outClientNumber >= 0 || outClientNumber < MAX_CLIENTS ) {
            *outClientInfo = &clgi.client->clientinfo[ outClientNumber ];
            return true;
        }
    }

    // Not a player model.
    return false;
}

/**
*   @brief  Checks for entity generated events and processes them for execution.
*           Entity events can be generated by either the entity type itself, or by riding with another entity.
* 
*   @note   This only processes entity events, not player state events. Player state events are handled separately.
*           Called once per entity per frame to check for any new events to process.
* 
*           Entity events are only processed once per event change, so if the event value hasn't changed since last frame, it won't be processed again.
* 
*           It will pass along the client info for player type entities based on the skinnum decoding.
* 
*   @param  cent        The client entity to check for events on.
**/
void CLG_Events_CheckForEntity( centity_t *cent ) {
    // The event value we'll process.
    int32_t eventValue = EV_NONE;

    /**
    *   Check for Entity Event - only entity types:
    **/
    if ( cent->current.entityType > ET_TEMP_ENTITY_EVENT ) {
        // Already fired for this entity.
        if ( cent->previousEvent ) {
            return;
        }
        // if this is a player event set the entity number of the client entity number
        if ( cent->current.entityFlags & EF_OTHER_ENTITY_EVENT ) {
            cent->current.number = cent->current.otherEntityNumber;
        }
        // Set previous event to true.
        cent->previousEvent = 1;
        // The event is simply the entity type minus the ET_EVENTS offset.
        cent->current.event = cent->current.entityType - ET_TEMP_ENTITY_EVENT;
    /**
    *   Check for events riding with another entity:
    **/
    } else {
        // Already fired the event.
        if ( cent->current.event == cent->previousEvent ) {
            return;
        }
        // Save as previous event.
        cent->previousEvent = cent->current.event;

        // Acquire the actual event value by offing it with EV_EVENT_BITS.
        eventValue = SG_GetEntityEventValue( cent->current.event );
        // If no event, don't process anything. ( It hasn't changed again. )
        if ( eventValue == 0 ) {
            return;
        }
    }

    /**
    *   Event Value Decoding:
    **/
    //  Get the entity state.
    entity_state_t *currentEntityState = &cent->current;
    // Acquire the actual event value by offing it with EV_EVENT_BITS.
    eventValue = SG_GetEntityEventValue( currentEntityState->event );
    #if 0
        //if ( cg_debugEvents.integer ) {
    clgi.Print( PRINT_DEVELOPER, "%s: entity(#%d), eventValue(%d), eventName(%s)\n", __func__, currentEntityState->number, eventValue, sg_event_string_names[ eventValue ] );
//}

    if ( !eventValue ) {
        //DEBUGNAME( "ZEROEVENT" );
        clgi.Print( PRINT_DEVELOPER, "%s: ZERO EVENT on entity(#%d)\n", __func__, currentEntityState->number );
        return;
    }
    #else
    if ( !eventValue ) {
        return;
    }
    #endif

    /**
    *   Client Info Decoding by skinnum from entity state:
    **/
    // The client info we'll acquire based on entity client number(decoded from skinnum if a player). 
    clientinfo_t *clientInfo = nullptr;
    // The client number of the entity, if any.
    int32_t clientNumber = -1;
	// Decode the client info from the entity state.
	DecodeClientInfoFromEntityState( currentEntityState, clientNumber, &clientInfo );

    // calculate the position at exactly the frame time
    //BG_EvaluateTrajectory( &cent->currentState.pos, cg.snap->serverTime, cent->lerpOrigin );
    //CG_SetEntitySoundPosition( cent );

    /**
    *   Determine LerpOrigin and Process the Entity Events:
    **/
    // Calculate the position for lerp_origin at exactly the frame time.
    CLG_GetEntitySoundOrigin( cent->current.number, &cent->lerp_origin.x );

    // Process the event.
    CLG_Events_ProcessEntityEvent( eventValue, cent->lerp_origin, cent, cent->current.number, clientNumber, clientInfo );
}



/**
*
*
*
*   PlayerState Event Handling:
*
*
*
**/
/**
*   @brief  Checks for player state generated events(usually by PMove) and processed them for execution.
*   @note   This only processes player state events, not entity events. Entity events are handled separately.
*           Called once per frame for the local player to check for any new events to process.
*   @param  ops                 The old player state.
*   @param  ps                  The current player state.
*   @param  playerStateEvent    The player state event to process.
*   @param  lerpOrigin          The origin to process the event at.
*   @return True if an event was processed, false otherwise.
**/
const bool CLG_Events_CheckForPlayerState( const player_state_t *ops, const player_state_t *ps, const int32_t playerStateEvent, const Vector3 &lerpOrigin ) {
	// Get the frame's client entity.
    //centity_t *cent = &clg_entities[ clgi.client->frame.clientNum + 1 ];

	// Entity has to be in the current frame to process though.
    //if ( cent->serverframe != clgi.client->frame.number ) {
    //    return false;
    //}
    
    // Is this the view bound entity?
    centity_t *viewBoundEntity = CLG_GetViewBoundEntity();
    // If the viewbound entity does not match, we won't process.
    if ( !viewBoundEntity ) {
        return false;
    }
    
    // Entity has to be in the current frame to process though.
    centity_t *cent = viewBoundEntity;
    if ( cent->serverframe != clgi.client->frame.number ) {
        return false;
    }

	// Process the player state event.
	return CLG_Events_ProcessPlayerStateEvent( cent, ops, ps, playerStateEvent, lerpOrigin );
}