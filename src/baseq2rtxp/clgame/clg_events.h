/********************************************************************
*
*
*	ClientGame: (Entity/Player State) -Events:
*
*
********************************************************************/
#pragma once

#include "shared/shared.h"
#include "shared/player_state.h"



/**
*
*
*
*	Core Entity Event Funcs:
*
*
*
**/
/**
*	Macros for debugging purposes:
**/
//! Debug print entity event name.
#define	DEBUG_PRINT_EVENT_NAME( eventNameStr ) \
	if( clg_debug_entity_events->integer ) \
	{ \
		clgi.Print( PRINT_DEVELOPER, "DEBUG EVENT: %s\n", eventNameStr ); \
	} \

//! Debug print sound resource info for entity events.
#define DBG_ENTITY_EVENT_SOUND_NAME_ENTITY( funcname, entity, soundIdx ) \
    if ( clg_debug_entity_events->integer ) { \
        const qhandle_t dbgSoundHandle = GetSoundIndexResourceHandle( soundIdx ); \
        const std::string dbgSoundName = GetSoundResourceHandleName( dbgSoundHandle ); \
        if ( !cent ) { \
            clgi.Print( PRINT_DEVELOPER, "EntityEvent[%s]: Sound Resource Index %d (handle: %d, name: '%s') on NULL entity!\n", funcname, soundIdx, dbgSoundHandle, dbgSoundName.c_str() ); \
        } else { \
            if ( ( cent->current.entityFlags & EF_ENTITY_EVENT_TARGET_OTHER ) != 0 && cent->current.otherEntityNumber > 0 ) { \
                clgi.Print( PRINT_DEVELOPER, "EntityEvent[%s]: Sound Resource Index %d (handle: %d, name: '%s') from entity(%d) on OTHER entity %d\n", funcname, soundIdx, dbgSoundHandle, dbgSoundName.c_str(), entity->current.number, entity->current.otherEntityNumber ); \
            } else { \
                clgi.Print( PRINT_DEVELOPER, "EntityEvent[%s]: Sound Resource Index %d (handle: %d, name: '%s') on entity %d\n", funcname, soundIdx, dbgSoundHandle, dbgSoundName.c_str(), entity->current.number ); \
            } \
        } \
    } \

#define DBG_ENTITY_EVENT_SOUND_NAME_ORIGIN( funcname, origin, soundIdx ) \
    if ( clg_debug_entity_events->integer ) { \
        const qhandle_t dbgSoundHandle = GetSoundIndexResourceHandle( soundIdx ); \
        const std::string dbgSoundName = GetSoundResourceHandleName( dbgSoundHandle ); \
        clgi.Print( PRINT_DEVELOPER, "EntityEvent[%s]: Sound Resource Index %d (handle: %d, name: '%s') at origin (%f, %f, %f)\n", funcname, soundIdx, dbgSoundHandle, dbgSoundName.c_str(), origin.x, origin.y, origin.z ); \
    } \


/**
*   @brief  Checks for entity generated events and processes them for execution.
*           Entity events can be generated by either the entity type itself, or by riding with another entity.
*
*   @note   This only processes entity events, not player state events. Player state events are handled separately.
*           Called once per entity per frame to check for any new events to process.
*
*           Entity events are only processed once per event change, so if the event value hasn't changed since last frame, it won't be processed again.
*
*           It will pass along the client info for player type entities based on the skinnum decoding.
*
*   @param  cent        The client entity to check for events on.
**/
void CLG_Events_CheckForEntity( centity_t *cent );

/**
*   @brief  Checks for player state generated events(usually by PMove) and processed them for execution.
*   @note   This only processes player state events, not entity events. Entity events are handled separately.
*           Called once per frame for the local player to check for any new events to process.
*   @param  ops                 The old player state.
*   @param  ps                  The current player state.
*   @param  playerStateEvent    The player state event to process.
*   @param  lerpOrigin          The origin to process the event at.
*   @return True if an event was processed, false otherwise.
**/
const bool CLG_Events_CheckForLocalPlayerState( const player_state_t *ops, const player_state_t *ps, const int32_t playerStateEvent, const int32_t playerStateEventParm0, const Vector3 &lerpOrigin );
