/********************************************************************
*
*
*	ClientGame: (Entity/Player State) -Events:
*
*
********************************************************************/
#pragma once



/**
*
*
*
*	Core Entity Event Funcs:
*
*
*
**/
/**
*	Macros for debugging purposes:
**/
//! Debug print entity event name.
#if USE_DEBUG
    // Debug print entity event name for '(Temporary-) Event Entities'..
    #define	DEBUG_PRINT_EVENT_NAME( eventNameStr ) \
	    if( clg_debug_entity_events->integer ) \
	    { \
		    clgi.Print( PRINT_DEVELOPER, "DEBUG EVENT: %s\n", eventNameStr ); \
	    } \

    //! Debug print entity info for 'Event Entities'..
    #define	DEBUG_PRINT_EVENT_ENTITY_INFO( cent ) \
        if ( clg_debug_entity_events->integer ) { \
            const int32_t eventValue = cent->current.event = cent->current.entityType - ET_TEMP_EVENT_ENTITY; \
            if ( eventValue >= EV_ENGINE_MAX ) { \
				if ( ( ( cent->current.entityFlags & EF_ENTITY_EVENT_TARGET_OTHER ) != 0 ) && otherEntityNumber > 0 ) { \
					clgi.Print( PRINT_DEVELOPER, "%s: rider_entity(#%d), target_entity(#%d), eventValue(#%d), eventName('%s')\n", __func__, cent->current.number, cent->current.otherEntityNumber, eventValue, sg_event_string_names[ eventValue ] ); \
				} else { \
					clgi.Print( PRINT_DEVELOPER, "%s: rider_entity(#%d), eventValue(#%d), eventName('%s')\n", __func__, cent->current.number, eventValue, sg_event_string_names[ eventValue ] ); \
				} \
            } \
		} \

	//! Debug print for 'entity event value' acquired from riding with another entity.
    #define DEBUG_PRINT_RIDER_EVENT_VALUE( cent ) \
        { \
            const int32_t eventValue = EV_GetEntityEventValue( cent->current.event ); \
            if ( eventValue >= EV_ENGINE_MAX && clg_debug_entity_events->integer ) { \
                clgi.Print( PRINT_DEVELOPER, "%s: entity(#%d), eventValue(#%d), eventName(%s)\n", __func__, cent->current.number, eventValue, sg_event_string_names[ eventValue ] ); \
            } \
            if ( eventValue == EV_NONE ) { \
                clgi.Print( PRINT_DEVELOPER, "%s: entity(#%d), EV_NONE\n", __func__, cent->current.number ); \
            } \
        }

    //! Debug print sound resource info for entity events.
    #define DBG_ENTITY_EVENT_SOUND_NAME_ENTITY( funcname, entity, soundIdx ) \
        if ( clg_debug_entity_events->integer ) { \
            const qhandle_t dbgSoundHandle = GetSoundIndexResourceHandle( soundIdx ); \
            const std::string dbgSoundName = GetSoundResourceHandleName( dbgSoundHandle ); \
            if ( !cent ) { \
                clgi.Print( PRINT_DEVELOPER, "EntityEvent[%s]: Sound Resource Index %d (handle: %d, name: '%s') on NULL entity!\n", funcname, soundIdx, dbgSoundHandle, dbgSoundName.c_str() ); \
            } else { \
                if ( ( cent->current.entityFlags & EF_ENTITY_EVENT_TARGET_OTHER ) != 0 && cent->current.otherEntityNumber > 0 ) { \
                    clgi.Print( PRINT_DEVELOPER, "EntityEvent[%s]: Sound Resource Index %d (handle: %d, name: '%s') from entity(%d) on OTHER entity %d\n", funcname, soundIdx, dbgSoundHandle, dbgSoundName.c_str(), entity->current.number, entity->current.otherEntityNumber ); \
                } else { \
                    clgi.Print( PRINT_DEVELOPER, "EntityEvent[%s]: Sound Resource Index %d (handle: %d, name: '%s') on entity %d\n", funcname, soundIdx, dbgSoundHandle, dbgSoundName.c_str(), entity->current.number ); \
                } \
            } \
        } \

    //! Debug print sound resource info for entity events at origin.
    #define DBG_ENTITY_EVENT_SOUND_NAME_ORIGIN( funcname, origin, soundIdx ) \
        if ( clg_debug_entity_events->integer ) { \
            const qhandle_t dbgSoundHandle = GetSoundIndexResourceHandle( soundIdx ); \
            const std::string dbgSoundName = GetSoundResourceHandleName( dbgSoundHandle ); \
            clgi.Print( PRINT_DEVELOPER, "EntityEvent[%s]: Sound Resource Index %d (handle: %d, name: '%s') at origin (%f, %f, %f)\n", funcname, soundIdx, dbgSoundHandle, dbgSoundName.c_str(), origin.x, origin.y, origin.z ); \
        } \

#else
    #define	DEBUG_PRINT_EVENT_NAME( ... )
    #define	DEBUG_PRINT_EVENT_ENTITY_INFO( ... )
    #define DEBUG_PRINT_RIDER_EVENT_VALUE( ... )
    #define DBG_ENTITY_EVENT_SOUND_NAME_ENTITY( ... )
    #define DBG_ENTITY_EVENT_SOUND_NAME_ORIGIN( ... )
#endif



/**
*   @brief  Checks for entity generated events and processes them for execution.
*           Entity events can be generated by either the entity type itself, or by riding with another entity.
*
*   @note   This only processes entity events, not player state events. Player state events are handled separately.
*           Called once per entity per frame to check for any new events to process.
*
*           Entity events are only processed once per event change, so if the event value hasn't changed since last frame, it won't be processed again.
*
*           It will pass along the client info for player type entities based on the skinnum decoding.
*
*   @param  cent        The client entity to check for events on.
*   @return EV_NONE in case there was no event fired, > EV_NONE otherwise.
**/
const int32_t CLG_Events_CheckForEntity( centity_t *cent );

/**
*   @brief  Checks for player state generated events(usually by PMove) and processed them for execution.
*   @note   This only processes player state events, not entity events. Entity events are handled separately.
*           Called once per frame for the local player to check for any new events to process.
*   @param  ops                 The old player state.
*   @param  ps                  The current player state.
*   @param  playerStateEvent    The player state event to process.
*   @param  lerpOrigin          The origin to process the event at.
*   @return True if an event was processed, false otherwise.
**/
const bool CLG_Events_CheckForPlayerState( centity_t *clientEntity, const player_state_t *ops, const player_state_t *ps, const int32_t playerStateEvent, const int32_t playerStateEventParm0, const Vector3 &lerpOrigin );
